#ifndef UR_KINEMATICS_AUTOGENERATED_H
#define UR_KINEMATICS_AUTOGENERATED_H

#define _USE_MATH_DEFINES
#include <math.h>

#include "Types.hpp"

#ifndef __host__
#define __host__
#endif

#ifndef __device__
#define __device__
#endif


namespace ur_kin {

#define ZERO_THRESH 0.00000001
#define SIGN(x) ( ( (x) > 0 ) - ( (x) < 0 ) )
#define PI M_PI


struct DHParams
{
    const float d1; const float a2; const float a3;
    const float d4; const float d5; const float d6;
};

const DHParams UR_10_DH{
    d1 : 0.1273,
    a2 : -0.612,
    a3 : -0.5723,
    d4 : 0.163941,
    d5 : 0.1157,
    d6 : 0.0922,
};

const DHParams UR_5_DH{
    d1 : 0.089159,
    a2 : -0.42500,
    a3 : -0.39225,
    d4 : 0.10915,
    d5 : 0.09465,
    d6 : 0.0823,
};

const DHParams UR_3_DH{
    d1 : 0.1519,
    a2 : -0.24365,
    a3 : -0.21325,
    d4 : 0.11235,
    d5 : 0.08535,
    d6 : 0.0819,
};

const DHParams UR_10E_DH{
    d1 : 0.1807,
    a2 : -0.6127,
    a3 : -0.57155,
    d4 : 0.17415,
    d5 : 0.11985,
    d6 : 0.11655,
};

const DHParams UR_5E_DH{
    d1 : 0.1625,
    a2 : -0.42500,
    a3 : -0.39220,
    d4 : 0.1333,
    d5 : 0.09970,
    d6 : 0.0996,
};

const DHParams UR_3E_DH{
    d1 : 0.15185,
    a2 : -0.24355,
    a3 : -0.2132,
    d4 : 0.13105,
    d5 : 0.08535,
    d6 : 0.0921,
};

const DHParams UR_16E_DH{
    d1 : 0.1807,
    a2 : -0.4784,
    a3 : -0.36,
    d4 : 0.17415,
    d5 : 0.11985,
    d6 : 0.11655,
};

__device__ __host__ inline void forward(const float* q, float* T, const DHParams& dh);
__device__ __host__ inline int backward(float* T, const float* q, const DHParams& dh);

__device__ __host__ inline void forward_(const float *q, float *T, const DHParams& dh);


__device__ __host__ 
inline mt::Matrix4f solveFK(mt::State state, const DHParams &dh = UR_5_DH)
{
    mt::Matrix4f fwd(0.f);
    forward(state.data, fwd.data, dh);
    return fwd;
}

__device__ __host__ 
inline mt::Matrix4f solveFK_(mt::State state, const DHParams& dh = UR_5_DH)
{
    mt::Matrix4f fwd(0.f);
    forward_(state.data, fwd.data, dh);
    return fwd;
}

// Returns the Denavit Hartenberg transformation between two adjacent joints, 
// where the transform goes from @param joint to joint+1
__device__ __host__ inline
mt::Matrix4f get_dh_transform(size_t joint, const mt::State& state, const DHParams& dh = UR_5_DH)
{
    if (joint > 5)
    {
        return mt::identity<4, 4>();
    }

    const float alpha_arr[6] = {M_PI_2, 0.f, 0.f, M_PI_2, -M_PI_2, 0.f};
    const float d_arr[6] = {dh.d1, 0.f, 0.f, dh.d4, dh.d5, dh.d6};
    const float a_arr[6] = {0.f, dh.a2, dh.a3, 0.f, 0.f, 0.f};

    const float theta = state.data[joint];
    const float ct = cos(theta);
    const float st = sin(theta);

    const float alpha = alpha_arr[joint];
    const float ca = cos(alpha);
    const float sa = sin(alpha);

    const float d = d_arr[joint];
    float a = a_arr[joint];

    mt::Matrix4f rot_z = mt::identity<4, 4>();
    rot_z.data[0 * 4 + 0] = ct;
    rot_z.data[1 * 4 + 1] = ct;
    rot_z.data[0 * 4 + 1] = -st;
    rot_z.data[1 * 4 + 0] = st;

    mt::Matrix4f trans_z = mt::identity<4, 4>();
    trans_z.data[2 * 4 + 3] = d;

    mt::Matrix4f trans_x = mt::identity<4, 4>();
    trans_x.data[0 * 4 + 3] = a;

    mt::Matrix4f rot_x = mt::identity<4, 4>();
    rot_x.data[1 * 4 + 1] = ca;
    rot_x.data[2 * 4 + 2] = ca;

    rot_x.data[1 * 4 + 2] = -sa;
    rot_x.data[2 * 4 + 1] = sa;

    return rot_z * trans_z * trans_x * rot_x;
}



__device__ __host__
void get_posture(mt::State& s)
{


}











__device__ __host__ inline void forward_(const float *q, float *T, const DHParams& dh)
{
    const float d1 = dh.d1;
    const float a2 = dh.a2;
    const float a3 = dh.a3;
    const float d4 = dh.d4;
    const float d5 = dh.d5;
    const float d6 = dh.d6;

    const float s1 = sin(q[0]);
    const float c1 = cos(q[0]);
    const float s2 = sin(q[1]);
    const float c2 = cos(q[1]);
    const float s3 = sin(q[2]);
    const float c3 = cos(q[2]);
    const float s5 = sin(q[4]);
    const float c5 = cos(q[4]);
    const float s6 = sin(q[5]);
    const float c6 = cos(q[5]);
    const float s234 = sin(q[1] + q[2] + q[3]);
    const float c234 = cos(q[1] + q[2] + q[3]);

    T[0] = ((c1 * c234 - s1 * s234) * s5) / 2.0 - c5 * s1 + ((c1 * c234 + s1 * s234) * s5) / 2.0;

    T[1] = (c6 * (s1 * s5 + ((c1 * c234 - s1 * s234) * c5) / 2.0 + ((c1 * c234 + s1 * s234) * c5) / 2.0) -
            (s6 * ((s1 * c234 + c1 * s234) - (s1 * c234 - c1 * s234))) / 2.0);

    T[2] = (-(c6 * ((s1 * c234 + c1 * s234) - (s1 * c234 - c1 * s234))) / 2.0 -
            s6 * (s1 * s5 + ((c1 * c234 - s1 * s234) * c5) / 2.0 + ((c1 * c234 + s1 * s234) * c5) / 2.0));

    T[3] = ((d5 * (s1 * c234 - c1 * s234)) / 2.0 - (d5 * (s1 * c234 + c1 * s234)) / 2.0 -
            d4 * s1 + (d6 * (c1 * c234 - s1 * s234) * s5) / 2.0 + (d6 * (c1 * c234 + s1 * s234) * s5) / 2.0 -
            a2 * c1 * c2 - d6 * c5 * s1 - a3 * c1 * c2 * c3 + a3 * c1 * s2 * s3);

    T[4] = c1 * c5 + ((s1 * c234 + c1 * s234) * s5) / 2.0 + ((s1 * c234 - c1 * s234) * s5) / 2.0;

    T[5] = (c6 * (((s1 * c234 + c1 * s234) * c5) / 2.0 - c1 * s5 + ((s1 * c234 - c1 * s234) * c5) / 2.0) +
            s6 * ((c1 * c234 - s1 * s234) / 2.0 - (c1 * c234 + s1 * s234) / 2.0));

    T[6] = (c6 * ((c1 * c234 - s1 * s234) / 2.0 - (c1 * c234 + s1 * s234) / 2.0) -
            s6 * (((s1 * c234 + c1 * s234) * c5) / 2.0 - c1 * s5 + ((s1 * c234 - c1 * s234) * c5) / 2.0));

    T[7] = ((d5 * (c1 * c234 - s1 * s234)) / 2.0 - (d5 * (c1 * c234 + s1 * s234)) / 2.0 + d4 * c1 +
            (d6 * (s1 * c234 + c1 * s234) * s5) / 2.0 + (d6 * (s1 * c234 - c1 * s234) * s5) / 2.0 + d6 * c1 * c5 -
            a2 * c2 * s1 - a3 * c2 * c3 * s1 + a3 * s1 * s2 * s3);

    T[8] = ((c234 * c5 - s234 * s5) / 2.0 - (c234 * c5 + s234 * s5) / 2.0);

    T[9] = ((s234 * c6 - c234 * s6) / 2.0 - (s234 * c6 + c234 * s6) / 2.0 - s234 * c5 * c6);

    T[10] = (s234 * c5 * s6 - (c234 * c6 + s234 * s6) / 2.0 - (c234 * c6 - s234 * s6) / 2.0);

    T[11] = (d1 + (d6 * (c234 * c5 - s234 * s5)) / 2.0 + a3 * (s2 * c3 + c2 * s3) + a2 * s2 -
             (d6 * (c234 * c5 + s234 * s5)) / 2.0 - d5 * c234);
    
    T[12] = 0.f;
    T[13] = 0.f;
    T[14] = 0.f;
    T[15] = 1.f;
}

__device__ __host__ inline
void forward(const float* q, float* T, const DHParams& dh)
{
    float s1 = sin(*q), c1 = cos(*q); q++;
    float q234 = *q, s2 = sin(*q), c2 = cos(*q); q++;
    float s3 = sin(*q), c3 = cos(*q); q234 += *q; q++;
    q234 += *q; q++;
    float s5 = sin(*q), c5 = cos(*q); q++;
    float s6 = sin(*q), c6 = cos(*q); 
    float s234 = sin(q234), c234 = cos(q234);

    const float d1 = dh.d1;
    const float a2 = dh.a2;
    const float a3 = dh.a3;
    const float d4 = dh.d4;
    const float d5 = dh.d5;
    const float d6 = dh.d6;

    *T = ((c1*c234-s1*s234)*s5)/2.0 - c5*s1 + ((c1*c234+s1*s234)*s5)/2.0; T++;
    *T = (c6*(s1*s5 + ((c1*c234-s1*s234)*c5)/2.0 + ((c1*c234+s1*s234)*c5)/2.0) - 
          (s6*((s1*c234+c1*s234) - (s1*c234-c1*s234)))/2.0); T++;
    *T = (-(c6*((s1*c234+c1*s234) - (s1*c234-c1*s234)))/2.0 - 
          s6*(s1*s5 + ((c1*c234-s1*s234)*c5)/2.0 + ((c1*c234+s1*s234)*c5)/2.0)); T++;
    *T = ((d5*(s1*c234-c1*s234))/2.0 - (d5*(s1*c234+c1*s234))/2.0 - 
          d4*s1 + (d6*(c1*c234-s1*s234)*s5)/2.0 + (d6*(c1*c234+s1*s234)*s5)/2.0 - 
          a2*c1*c2 - d6*c5*s1 - a3*c1*c2*c3 + a3*c1*s2*s3); T++;
    *T = c1*c5 + ((s1*c234+c1*s234)*s5)/2.0 + ((s1*c234-c1*s234)*s5)/2.0; T++;
    *T = (c6*(((s1*c234+c1*s234)*c5)/2.0 - c1*s5 + ((s1*c234-c1*s234)*c5)/2.0) + 
          s6*((c1*c234-s1*s234)/2.0 - (c1*c234+s1*s234)/2.0)); T++;
    *T = (c6*((c1*c234-s1*s234)/2.0 - (c1*c234+s1*s234)/2.0) - 
          s6*(((s1*c234+c1*s234)*c5)/2.0 - c1*s5 + ((s1*c234-c1*s234)*c5)/2.0)); T++;
    *T = ((d5*(c1*c234-s1*s234))/2.0 - (d5*(c1*c234+s1*s234))/2.0 + d4*c1 + 
          (d6*(s1*c234+c1*s234)*s5)/2.0 + (d6*(s1*c234-c1*s234)*s5)/2.0 + d6*c1*c5 - 
          a2*c2*s1 - a3*c2*c3*s1 + a3*s1*s2*s3); T++;
    *T = ((c234*c5-s234*s5)/2.0 - (c234*c5+s234*s5)/2.0); T++;
    *T = ((s234*c6-c234*s6)/2.0 - (s234*c6+c234*s6)/2.0 - s234*c5*c6); T++;
    *T = (s234*c5*s6 - (c234*c6+s234*s6)/2.0 - (c234*c6-s234*s6)/2.0); T++;
    *T = (d1 + (d6*(c234*c5-s234*s5))/2.0 + a3*(s2*c3+c2*s3) + a2*s2 - 
         (d6*(c234*c5+s234*s5))/2.0 - d5*c234); T++;
    *T = 0.0; T++; *T = 0.0; T++; *T = 0.0; T++; *T = 1.0;
}

__device__ __host__ inline
int backward(const float* T, float* q_sols, float q6_des, const DHParams& dh)
{
    int num_sols = 0;
    float T02 = -*T; T++; float T00 =  *T; T++; float T01 =  *T; T++; float T03 = -*T; T++; 
    float T12 = -*T; T++; float T10 =  *T; T++; float T11 =  *T; T++; float T13 = -*T; T++; 
    float T22 =  *T; T++; float T20 = -*T; T++; float T21 = -*T; T++; float T23 =  *T;

    const float d1 = dh.d1;
    const float a2 = dh.a2;
    const float a3 = dh.a3;
    const float d4 = dh.d4;
    const float d5 = dh.d5;
    const float d6 = dh.d6;

    ////////////////////////////// shoulder rotate joint (q1) //////////////////////////////
    float q1[2];
    {
      float A = d6*T12 - T13;
      float B = d6*T02 - T03;
      float R = A*A + B*B;
      if(fabs(A) < ZERO_THRESH) {
        float div;
        if(fabs(fabs(d4) - fabs(B)) < ZERO_THRESH)
          div = -SIGN(d4)*SIGN(B);
        else
          div = -d4/B;

        if (fabs(div) > 1.0)
        {
            return num_sols;
        }
        float arcsin = asin(div);
        if(fabs(arcsin) < ZERO_THRESH)
          arcsin = 0.0;
        if(arcsin < 0.0)
          q1[0] = arcsin + 2.0*PI;
        else
          q1[0] = arcsin;
        q1[1] = PI - arcsin;
      }
      else if(fabs(B) < ZERO_THRESH) {
        float div;
        if(fabs(fabs(d4) - fabs(A)) < ZERO_THRESH)
          div = SIGN(d4)*SIGN(A);
        else
        {
          div = d4/A;
        }

        if (fabs(div) > 1.0)
        {
            return num_sols;
        }

        float arccos = acos(div);
        q1[0] = arccos;
        q1[1] = 2.0*PI - arccos;
      }
      else if(d4*d4 > R) {
        return num_sols;
      }
      else {
        float div = d4 / sqrt(R);
        if (fabs(div) > 1.0)
        {
            return num_sols;
        }
        float arccos = acos(div) ;
        float arctan = atan2(-B, A);
        float pos = arccos + arctan;
        float neg = -arccos + arctan;
        if(fabs(pos) < ZERO_THRESH)
          pos = 0.0;
        if(fabs(neg) < ZERO_THRESH)
          neg = 0.0;
        if(pos >= 0.0)
          q1[0] = pos;
        else
          q1[0] = 2.0*PI + pos;
        if(neg >= 0.0)
          q1[1] = neg; 
        else
          q1[1] = 2.0*PI + neg;
      }
    }
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////// wrist 2 joint (q5) //////////////////////////////
    float q5[2][2];
    {
      for(int i=0;i<2;i++) {
        float numer = (T03*sin(q1[i]) - T13*cos(q1[i])-d4);
        float div;
        if(fabs(fabs(numer) - fabs(d6)) < ZERO_THRESH)
          div = SIGN(numer) * SIGN(d6);
        else
          div = numer / d6;

        if (fabs(div) > 1.0)
        {
            return 0;
        }

        float arccos = acos(div);
        q5[i][0] = arccos;
        q5[i][1] = 2.0*PI - arccos;
      }
    }
    ////////////////////////////////////////////////////////////////////////////////

     {
       for(int i=0;i<2;i++) {
         for(int j=0;j<2;j++) {
           float c1 = cos(q1[i]), s1 = sin(q1[i]);
           float c5 = cos(q5[i][j]), s5 = sin(q5[i][j]);
           float q6;
           ////////////////////////////// wrist 3 joint (q6) //////////////////////////////
           if(fabs(s5) < ZERO_THRESH)
             q6 = q6_des;
           else {
             q6 = atan2(SIGN(s5)*-(T01*s1 - T11*c1), 
                        SIGN(s5)*(T00*s1 - T10*c1));
             if(fabs(q6) < ZERO_THRESH)
               q6 = 0.0;
             if(q6 < 0.0)
               q6 += 2.0*PI;
           }
           ////////////////////////////////////////////////////////////////////////////////

           float q2[2], q3[2], q4[2];
           ///////////////////////////// RRR joints (q2,q3,q4) ////////////////////////////
           float c6 = cos(q6), s6 = sin(q6);
           float x04x = -s5*(T02*c1 + T12*s1) - c5*(s6*(T01*c1 + T11*s1) - c6*(T00*c1 + T10*s1));
           float x04y = c5*(T20*c6 - T21*s6) - T22*s5;
           float p13x = d5*(s6*(T00*c1 + T10*s1) + c6*(T01*c1 + T11*s1)) - d6*(T02*c1 + T12*s1) + 
                         T03*c1 + T13*s1;
           float p13y = T23 - d1 - d6*T22 + d5*(T21*c6 + T20*s6);

           float c3 = (p13x*p13x + p13y*p13y - a2*a2 - a3*a3) / (2.0*a2*a3);
           if(fabs(fabs(c3) - 1.0) < ZERO_THRESH)
             c3 = SIGN(c3);
           else if(fabs(c3) > 1.0) {
             // TODO NO SOLUTION
             continue;
           }
           float arccos = acos(c3);
           q3[0] = arccos;
           q3[1] = 2.0*PI - arccos;
           float denom = a2*a2 + a3*a3 + 2*a2*a3*c3;
           if (fabs(denom) < ZERO_THRESH)
           {
               continue;
           }

           float s3 = sin(arccos);
           float A = (a2 + a3*c3), B = a3*s3;
           q2[0] = atan2((A*p13y - B*p13x) / denom, (A*p13x + B*p13y) / denom);
           q2[1] = atan2((A*p13y + B*p13x) / denom, (A*p13x - B*p13y) / denom);
           float c23_0 = cos(q2[0]+q3[0]);
           float s23_0 = sin(q2[0]+q3[0]);
           float c23_1 = cos(q2[1]+q3[1]);
           float s23_1 = sin(q2[1]+q3[1]);
           q4[0] = atan2(c23_0*x04y - s23_0*x04x, x04x*c23_0 + x04y*s23_0);
           q4[1] = atan2(c23_1*x04y - s23_1*x04x, x04x*c23_1 + x04y*s23_1);
           ////////////////////////////////////////////////////////////////////////////////
           for(int k=0;k<2;k++) {
             if(fabs(q2[k]) < ZERO_THRESH)
               q2[k] = 0.0;
             else if(q2[k] < 0.0) q2[k] += 2.0*PI;
             if(fabs(q4[k]) < ZERO_THRESH)
               q4[k] = 0.0;
             else if(q4[k] < 0.0) q4[k] += 2.0*PI;
             q_sols[num_sols*6+0] = q1[i];    q_sols[num_sols*6+1] = q2[k]; 
             q_sols[num_sols*6+2] = q3[k];    q_sols[num_sols*6+3] = q4[k]; 
             q_sols[num_sols*6+4] = q5[i][j]; q_sols[num_sols*6+5] = q6; 
             num_sols++;
           }
       }
     }
     return num_sols;
   }
}



}; // namespace ur_kin
#endif
